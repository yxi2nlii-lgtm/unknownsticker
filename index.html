<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blynk 按钮 + 动态表情</title>
    <style>
        /* 统一线条粗细变量 */
        :root {
            --line-thickness: 10px;
            --eye-height: 35px;
            /* 初始颜色：完全透明 */
            --face-color: transparent; 
            --max-move-distance: 30px; 
            --max-squeeze-scale: 0.90; 
            --max-stretch-scale: 1.05;
            --face-shift-ratio: 0.15; 
            --face-padding: 50px; 
        }
        
        /* 1. 页面整体样式 */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%; 
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #FFFFFF; 
            padding: var(--face-padding);
            box-sizing: border-box; 
            position: relative; 
            overflow: hidden; 
            font-family: sans-serif;
        }

        /* Blynk 状态提示：底部、小字号、不显眼 */
        #blynk-status {
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #777;
            opacity: 0.8;
            pointer-events: none; /* 不挡点击 */
        }

        /* 2. 表情容器 (大圆脸 = 按钮本体) 
           ⚠ 已缩小：65vw & max-width 260px */
        .emoji-container {
            width: 65vw;        
            max-width: 260px;    
            height: auto; 
            aspect-ratio: 1 / 1; 
            
            background-color: var(--face-color); /* 初始透明 */
            border-radius: 50%; 
            position: relative;
            box-shadow: none; /* 初始无阴影，由 JS 动态设置 */
            cursor: pointer;
            
            transition: transform 0.1s ease-out,
                        box-shadow 0.1s ease-out,
                        background-color 0.5s ease; 
            overflow: hidden; 
        }

        /* 3. 五官容器 (内部移动层) */
        .features-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out; 
            opacity: 1; 
        }

        /* 4. 眼睛和嘴巴的通用样式 */
        .eye, .mouth {
            position: absolute;
            background-color: black;
        }

        /* 5. 眼睛样式 + 眨眼动画 */
        .eye {
            width: var(--line-thickness); 
            height: var(--eye-height); 
            top: 35%; 
            animation: blink 4s infinite; 
        }

        .left-eye {
            left: 35%;
            transform: translateX(-50%);
        }

        .right-eye {
            right: 35%;
            transform: translateX(50%);
        }

        /* 嘴巴：下方一个小弧线 */
        .mouth {
            width: 80px;
            height: 80px;
            border: var(--line-thickness) solid black; 
            border-color: transparent transparent black transparent; 
            border-radius: 50%;
            bottom: 25%;
            right: 30%; 
            transform: rotate(-45deg); 
            background-color: transparent; 
        }
        
        /* 眨眼动画 */
        @keyframes blink {
            0%, 45%, 100% {
                height: var(--eye-height);
            }
            50%, 52% {
                height: var(--line-thickness);
            }
        }
        
        /* 点击轻微缩放抖动 */
        @keyframes shake {
            0%   { transform: scale(1.0); }
            50%  { transform: scale(0.98); } 
            100% { transform: scale(1.0); } 
        }
        
        .click-shake {
            animation: shake 0.2s ease-in-out; 
        }
    </style>
</head>
<body>
    <div id="blynk-status">Blynk Status: Idle</div>

    <div class="emoji-container" id="emojiContainer">
        <div class="features-wrapper" id="featuresWrapper">
            <div class="eye left-eye"></div>
            <div class="eye right-eye"></div>
            <div class="mouth"></div>
        </div>
    </div>
    
    <script>
        const container = document.getElementById('emojiContainer');
        const wrapper = document.getElementById('featuresWrapper');
        const root = document.documentElement; 
        const statusEl = document.getElementById('blynk-status');

        /* ========= Blynk 配置 ========= */
        const AUTH_TOKEN   = 'OqSFS2EppKQRi0DYBOTFNEQgW7pljRjT'; // 可以换成你自己的
        const BLYNK_HOST   = 'blynk.cloud';
        const VIRTUAL_PIN  = 'V1';
        const PICKUP_ANGLE = 120;
        const RETURN_ANGLE = 0;
        /* ============================== */

        // --- 颜色和状态常量（表情逻辑） ---
        const TARGET_HUE        = 0;    // 红色系
        const TARGET_SATURATION = 100;  
        const TARGET_LIGHTNESS  = 70;   

        const MAX_CLICKS          = 10;     // “最深颜色”对应的点击数
        const DECAY_DURATION_SEC  = 30;     // 从满到完全消退所需时间
        const DECAY_RATE_PER_SEC  = MAX_CLICKS / DECAY_DURATION_SEC; 

        // --- 状态变量 ---
        let clickCount   = 0; 
        let decayInterval = null; 
        
        // --- 移动和聚拢常量 ---
        const maxDistance      = parseFloat(getComputedStyle(root).getPropertyValue('--max-move-distance')) || 30;
        const maxSqueezeScale  = parseFloat(getComputedStyle(root).getPropertyValue('--max-squeeze-scale')) || 0.90;
        const maxStretchScale  = parseFloat(getComputedStyle(root).getPropertyValue('--max-stretch-scale')) || 1.05;
        const faceShiftRatio   = parseFloat(getComputedStyle(root).getPropertyValue('--face-shift-ratio')) || 0.15;


        /* ========== Blynk API 调用 ========== */
        async function sendCommand(value) { 
            const url_push  = `https://${BLYNK_HOST}/external/api/update?token=${AUTH_TOKEN}&${VIRTUAL_PIN}=${value}`;
            const url_reset = `https://${BLYNK_HOST}/external/api/update?token=${AUTH_TOKEN}&${VIRTUAL_PIN}=${RETURN_ANGLE}`;

            statusEl.innerText = `Blynk Status: Sending ${value}° PUSH...`;

            try {
                const response_push = await fetch(url_push);
                if (!response_push.ok) {
                    statusEl.innerText = `Blynk Status: PUSH Failed! (Code: ${response_push.status})`;
                    return; 
                }

                statusEl.innerText = `Blynk Status: PUSH Success. Sending 0° RESET...`;

                const response_reset = await fetch(url_reset);
                if (response_reset.ok) {
                    statusEl.innerText = `Blynk Status: Command ${value}° Sent & Cloud Reset Successfully!`;
                } else {
                    statusEl.innerText = `Blynk Status: PUSH Success, but RESET Failed! (Code: ${response_reset.status})`;
                }

            } catch (error) {
                console.error('Network error:', error);
                statusEl.innerText = `Blynk Status: Network Error! Could not reach Blynk.`;
            }
        }
        /* ==================================== */


        // --- 状态存储函数 ---
        function saveState() {
            localStorage.setItem('emojiClickCount', clickCount);
            localStorage.setItem('emojiLastUpdateTime', Date.now());
        }

        // --- 根据 clickCount 更新颜色 & 阴影 ---
        function updateColor() {
            const progress = clickCount / MAX_CLICKS; // 0–1

            const currentSaturation = Math.round(TARGET_SATURATION * progress);
            const currentLightness  = Math.round(100 - (100 - TARGET_LIGHTNESS) * progress);

            if (progress === 0) {
                root.style.setProperty('--face-color', 'transparent');
                container.style.boxShadow = 'none'; 
            } else {
                const hslColor = `hsl(${TARGET_HUE}, ${currentSaturation}%, ${currentLightness}%)`;
                root.style.setProperty('--face-color', hslColor);
                
                const shadowOffsetY = 4 * progress;
                const shadowBlur    = 15 + 10 * progress;
                const shadowSpread  = 0;
                const shadowOpacity = 0.1 + 0.2 * progress;

                container.style.boxShadow =
                    `0 ${shadowOffsetY}px ${shadowBlur}px ${shadowSpread}px rgba(0, 0, 0, ${shadowOpacity})`; 
            }
        }

        // --- 衰减逻辑，每秒运行一次 ---
        function updateDecay() {
            if (clickCount <= 0) {
                clickCount = 0; 
                clearInterval(decayInterval);
                decayInterval = null;
                updateColor(); 
                saveState(); 
                return;
            }

            const stepsToDecay = 1 * DECAY_RATE_PER_SEC; 
            clickCount = Math.max(0, clickCount - stepsToDecay);
            
            updateColor();
            saveState(); 
        }

        // --- 点击事件：同时更新表情 & 调用 Blynk ---
        function handleClickEffect(event) {
            event.preventDefault();

            // 1. 抖一下
            container.classList.remove('click-shake');
            void container.offsetWidth; 
            container.classList.add('click-shake');
            
            // 2. 表情逻辑：点击数 +1，更新颜色并存储
            clickCount = Math.min(MAX_CLICKS, clickCount + 1);
            updateColor();
            saveState(); 
            
            if (!decayInterval) {
                decayInterval = setInterval(updateDecay, 1000); 
            }

            // 3. 触发 Blynk 舵机动作
            sendCommand(PICKUP_ANGLE);
        }
        
        // --- 鼠标/手指移动时，五官跟随 & 挤压 ---
        function handleInteraction(event) {
            event.preventDefault();

            container.classList.remove('click-shake');
            
            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : undefined);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : undefined);
            if (clientX === undefined || clientY === undefined) return;

            const containerRect    = container.getBoundingClientRect();
            const containerCenterX = containerRect.left + containerRect.width / 2;
            const containerCenterY = containerRect.top + containerRect.height / 2;
            
            let dx = clientX - containerCenterX;
            let dy = clientY - containerCenterY;

            const distance = Math.sqrt(dx * dx + dy * dy);
            let moveX = dx;
            let moveY = dy;
            
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                moveX = dx * ratio;
                moveY = dy * ratio;
            }

            // 整个脸轻微反方向移动
            const faceMoveX = moveX * -faceShiftRatio; 
            const faceMoveY = moveY * -faceShiftRatio; 
            container.style.transform = `translate(${faceMoveX}px, ${faceMoveY}px)`;
            
            // 计算挤压/拉伸比例
            let scaleX = 1;
            let scaleY = 1;
            
            if (Math.abs(moveX) > Math.abs(moveY)) {
                const horizontalRatio = Math.abs(moveX) / maxDistance;
                scaleX = 1 - (1 - maxSqueezeScale) * horizontalRatio; 
                scaleY = 1 + (maxStretchScale - 1) * horizontalRatio;
            } else if (Math.abs(moveY) > Math.abs(moveX)) {
                const verticalRatio = Math.abs(moveY) / maxDistance;
                scaleY = 1 - (1 - maxSqueezeScale) * verticalRatio; 
                scaleX = 1 + (maxStretchScale - 1) * verticalRatio;
            }

            wrapper.style.transform =
                `translate(${moveX}px, ${moveY}px) scaleX(${scaleX}) scaleY(${scaleY})`;
        }

        // --- 放开鼠标/手指时复位 ---
        function resetPosition() {
            wrapper.style.transform   = 'translate(0, 0) scaleX(1) scaleY(1)';
            container.style.transform = 'translate(0, 0)';
            container.classList.remove('click-shake');
        }

        // --- 初始化：从 localStorage 恢复颜色状态 ---
        function initializeState() {
            const savedCount  = localStorage.getItem('emojiClickCount');
            const lastUpdate  = localStorage.getItem('emojiLastUpdateTime');
            const currentTime = Date.now();

            if (savedCount && lastUpdate) {
                let initialCount = parseFloat(savedCount);
                const elapsedMs  = currentTime - parseInt(lastUpdate, 10);
                const elapsedSec = elapsedMs / 1000;

                const decayAmount = elapsedSec * DECAY_RATE_PER_SEC;
                clickCount = Math.max(0, initialCount - decayAmount);
            } else {
                clickCount = 0;
            }

            updateColor(); 

            if (clickCount > 0) {
                decayInterval = setInterval(updateDecay, 1000); 
            }
        }

        // --- 启动 ---
        initializeState(); 

        // 交互事件
        document.addEventListener('mousemove', handleInteraction);
        document.addEventListener('touchmove', handleInteraction, { passive: false });
        
        container.addEventListener('click', handleClickEffect);
        container.addEventListener('touchstart', handleClickEffect, { passive: false }); 

        document.addEventListener('mouseup', resetPosition);
        document.addEventListener('touchend', resetPosition);
        document.addEventListener('touchcancel', resetPosition);
        container.addEventListener('contextmenu', (e) => e.preventDefault()); 
    </script>
</body>
</html>
